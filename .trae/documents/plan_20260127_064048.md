# 为pi0.6*实现CE损失功能

## 1. 需求分析
- **核心要求**：为pi0.6*实现CE损失，作为复合损失函数的核心组成部分
- **复用逻辑**：直接复用pi0_fast在Policy类compute_loss方法中的CE损失逻辑
- **激活方式**：通过配置参数`use_fast_tokenization: True`激活
- **损失组合**：新增优势指示器Token的损失分支，与原有FAST动作Token损失按1:1权重求和
- **工程兼容**：基于pi0.5现有离散Token自回归架构，复用loss_mask掩码逻辑与CE计算代码

## 2. 实现方案

### 2.1 配置扩展
- 在`pi0_config.py`中添加`use_fast_tokenization`配置参数
- 默认为`False`，保持现有行为

### 2.2 模型初始化修改
- 在`pi0.py`的`__init__`方法中，根据`use_fast_tokenization`配置初始化相关组件

### 2.3 compute_loss方法增强
- 当`use_fast_tokenization`为`True`时，添加CE损失计算逻辑
- 复用pi0_fast的tokenized_prompt和token_loss_mask处理逻辑
- 新增优势指示器Token的损失分支
- 与原有flow matching损失按适当权重组合

### 2.4 优势指示器Token支持
- 确保模型能够处理优势指示器Token
- 添加相应的掩码和损失计算逻辑

## 3. 具体修改步骤

### 3.1 修改pi0_config.py
- 添加`use_fast_tokenization`配置参数
- 设置默认值为`False`

### 3.2 修改pi0.py
- 在`__init__`方法中添加`use_fast_tokenization`属性
- 修改`compute_loss`方法，添加CE损失计算逻辑
- 实现优势指示器Token的损失分支
- 组合CE损失和flow matching损失

### 3.3 测试验证
- 确保修改后的代码能够正常运行
- 验证CE损失计算正确
- 验证优势指示器Token损失分支正常工作

## 4. 预期结果
- pi0.6*模型能够使用CE损失进行训练
- 通过配置参数可以控制是否使用FAST tokenization
- 优势指示器Token损失与FAST动作Token损失按1:1权重求和
- 与现有代码结构保持兼容